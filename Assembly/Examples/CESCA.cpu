#subruledef REG {
    R0 => 0b00
    R1 => 0b01
    R2 => 0b10
    R3 => 0b11
}

; The order of the bits is flipped because I made a mistake in the
; wiring and it's much easier to fix it this way.
#subruledef AluOpA {
    MOV => 0b0000
    NOT => 0b1110
    SLL => 0b0011
    SRL => 0b1011
    SRA => 0b0111
    ROL => 0b1111
}
#subruledef AluOpAB {
    ADD  => 0b1000
    SUB  => 0b0100
    ADDC => 0b1100
    SUBB => 0b0010
    AND  => 0b1010
    OR   => 0b0110
    XOR  => 0b0001
    NAND => 0b1001
    NOR  => 0b0101
    XNOR => 0b1101
}

#subruledef ADDR {
    skip({Off: i8})   =>  pc+Off+1  ; Skips a number of instructions
    {Imm: u8}   =>   Imm
}

#ruledef Instructions {
    ; ARITHMETIC AND LOGIC OPERATIONS
    
    {Op: AluOpA}  {Rd: REG}, {Ra: REG}              =>  0x0 @ Rd`2 @ Ra`2 @ Op`4 @ 0x0
    {Op: AluOpAB} {Rd: REG}, {Ra: REG}, {Rb: REG}   =>  0x0 @ Rd`2 @ Ra`2 @ Op`4 @ 0b00 @ Rb`2
    
    ADDI {Rd: REG}, {Ra: REG}, {Imm: i8}    =>  0x1 @ Rd`2 @ Ra`2 @ Imm
    
    CMP-{Op: AluOpA}  {Ra: REG}             =>  0x2 @ 0b00 @ Ra`2 @ Op`4 @ 0x0
    CMP-{Op: AluOpAB} {Ra: REG}, {Rb: REG}  =>  0x2 @ 0b00 @ Ra`2 @ Op`4 @ 0b00 @ Rb`2
    
    CMP-SUBI {Ra: REG}, {Imm: i8}   =>  0x2 @ 0b01 @ Ra`2 @ Imm
    
    CMP-ANDI {Ra: REG}, {Imm: i8}   =>  0x2 @ 0b10 @ Ra`2 @ Imm
    
    CMP-IN {Imm: i8}                =>  0x2C @ Imm
    
    
    ; DATA MOVEMENT
    
    MOVI {Rd: REG}, {Imm: i8}       =>  0x3 @ Rd`2 @ 0b00 @ Imm
    
    IN {Rd: REG}                    =>  0x4 @ Rd`2 @ 0b00 @ 0x00
    
    IN-Ack                          =>  0x5000
    
    ST-Addr {Ra: REG}, {Addr: u8}   =>  0x5 @ 0b01 @ Ra`2 @ Addr
    
    ST-Reg {Ra: REG}, {Rb: REG}     =>  0x5 @ 0b10 @ Ra`2 @ 0b000000 @ Rb`2
    
    PUSH {Ra: REG}                  =>  0x5 @ 0b11 @ Ra`2 @ 0x00
    
    LD-Addr {Rd: REG}, {Addr: u8}   =>  0x6 @ Rd`2 @ 0b00 @ Addr
    
    LD-Reg {Rd: REG}, {Ra: REG}     =>  0x7 @ Rd`2 @ Ra`2 @ 0x00
    
    POP {Rd: REG}                   =>  0x8 @ Rd`2 @ 0b00 @ 0x00
    
    SWAP {Rd: REG}, {Ra: REG}       =>  0x9 @ Rd`2 @ Ra`2 @ 0x00
    
    
    ; JUMP INSTRUCTIONS
    
    J {Addr: ADDR}          =>  0xA0 @ Addr
    
    JR {Ra: REG}            =>  0xA @ 0b01 @ Ra`2 @ 0x00
    
    CALL {Addr: ADDR}       =>  0xA8 @ Addr
    
    RET                     =>  0xAC00
    
    JZ {Addr: ADDR}         =>  0xB0 @ Addr`8
    
    JNZ {Addr: ADDR}        =>  0xB4 @ Addr`8
    
    JC {Addr: ADDR}         =>  0xB8 @ Addr`8
    
    JNC {Addr: ADDR}        =>  0xBC @ Addr`8
    
    JV {Addr: ADDR}         =>  0xC0 @ Addr`8
    
    JNV {Addr: ADDR}        =>  0xC4 @ Addr`8
    
    JN {Addr: ADDR}         =>  0xC8 @ Addr`8
    
    JP {Addr: ADDR}         =>  0xCC @ Addr`8
    
    JSP {Addr: ADDR}        =>  0xD0 @ Addr`8
    
    JLEU {Addr: ADDR}       =>  0xD4 @ Addr`8
    
    JLT {Addr: ADDR}        =>  0xD8 @ Addr`8
    
    JLE {Addr: ADDR}        =>  0xDC @ Addr`8
    
    
    ; OUTPUT AND MISC.
    
    LCD-Com {Imm: i8}       =>  0xE0 @ Imm
    
    LCD-Imm {Imm: i8}       =>  0xE4 @ Imm
    
    LCD-Reg {Ra: REG}       =>  0xE @ 0b10 @ Ra`2 @ 0x00
    
    LCD-Addr {Addr: u8}     =>  0xEC @ Addr
    
    OUT-Reg {Ra: REG}       =>  0xF @ 0b00 @ Ra`2 @ 0x00
    
    OUT-Addr {Addr: u8}     =>  0xF4 @ Addr
    
    HLT                     =>  0xF800
    
    NOP                     =>  0xFFFF
    
}

#ruledef Macros {
    CMP {Ra: REG}, {Rb: REG}    =>  0x2 @ 0b00 @ Ra`2 @ 0b0100 @ 0b00 @ Rb`2
    CMP {Ra: REG}, {Imm: i8}    =>  0x2 @ 0b01 @ Ra`2 @ Imm
    TEST {Ra: REG}              =>  0x2 @ 0b00 @ Ra`2 @ 0x00
    
    INC  {Ra: REG}              =>  0x1 @ Ra`2 @ Ra`2 @ 0x01
    DEC  {Ra: REG}              =>  0x1 @ Ra`2 @ Ra`2 @ 0xFF
    SLLC {Rd: REG}, {Ra: REG}   =>  0x0 @ Rd`2 @ Ra`2 @ 0b1100 @ 0b00 @ Ra`2
    SWAP {Ra: REG}              =>  0x9 @ Ra`2 @ Ra`2 @ 0x00
    
    LCD-Init                    =>  0xE0 @ 0x38 @ 0xE0 @ 0x0E @ 0xE0 @ 0x06
    LCD-Clr                     =>  0xE0 @ 0x01
    
    JEQ  {Addr: ADDR}           =>  0xB0 @ Addr`8
    JNE  {Addr: ADDR}           =>  0xB4 @ Addr`8
    JLTU {Addr: ADDR}           =>  0xB8 @ Addr`8
    JNIN {Addr: ADDR}           =>  0x2CFFB0 @ Addr`8
}

; CESCA MEMORY BANKS:
; Program memory: Banks 00 and 01 -> 512 bytes
#bankdef program {
    #bits 16
    #addr 0
    #size 0x100
    #outp 0
    #fill
}

; Data memory: Bank 10 -> 256 bytes
#bankdef data {
    #bits 8
    #addr 0
    #size 0x100
    #outp 0x200*8   ; Output location in bits
    #fill
}

; Stack: Bank 11 (cannot be programmed directly)
